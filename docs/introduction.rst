Introduction
============

Fuzzy SQL is developed to enable the comparison between real and synthetic datasets that are generated by any ML technique. Fuzzy SQL will generate semantically and syntactically correct SELECT random queries that are simultaneously applied to both inputs of real and synthetic datasets. The tool returns all query results along with the corresponding query parameters such as the SQL statement. The query results may be further analyzed to measure distances between real and synthetic responses to each query.

The input datasets may be either tabular of longitudinal. 

For tabular data, we define two basic types of SELECT queries, namely, 'filter' queries and 'aggregate' queries. For comparing real and synthetic datasets, usually 'aggregate' queries are used. This will allow the analyst to compare the resulting aggregate values from both datasets. Metrics, such as the Hellinger distance, can be applied to the aggregate query results in the same manner they are applied to the original datasets. On the other hand, an analyst may be interested to combine both filter and aggregate types of queries since filter queries may represent inclusion-exclusion criteria. Accordingly, we define a third type of queries and we call it 'filter-aggregate' query.  

If the input data includes continuous variables, various 'aggregate functions' may be randomly applied in addition to counting the resulting number of records. These functions are limited to AVG, SUM, MIN and MAX. If the input doe snot include any continuous variable, only the COUNT aggregate function is applied. The types of each variable are typically defined by the user and inputted along with the real and synthetic datasets.   


Query Templates for Tabular Datasets
------------------------------------
Without loss of generality, and to simplify the mathematical constructs, we herein ignore the logical operation 'NOT' and the value comparison operations  BETWEEN, LIKE and IN. We further consider that the same set of value comparison operations is applicable to all types of variables. In practice, a distinction in their applicability is made. Further, all the aforementioned operations are considered. Define:

:math:`\mathcal{T}^r` : Database table for real data.

:math:`\mathcal{T}^s`: Database table for synthetic data

:math:`N`: The number of records in both :math:`\mathcal{T}^r` and :math:`\mathcal{T}^s`.

:math:`\mathbb{A}^n=\{A^n_1,A^n_2, \cdots, A^n_{|\mathbb{A}^n|}\}` is the set of *nominal* variables in both :math:`\mathcal{T}^r` and :math:`\mathcal{T}^s` where :math:`|\mathbb{A}^n|` indicates the number of these variables.


:math:`\mathbb{A}^c=\{A^c_1,A^c_2, \cdots, A^c_{|\mathbb{A}^c|}\}` is the set of *continuous* variables in both :math:`\mathcal{T}^r` and :math:`\mathcal{T}^s`.

:math:`\mathbb{A}^d=\{A^d_1,A^d_2, \cdots, A^d_{|\mathbb{A}^d|}\}` is the set of *date* variables in both :math:`\mathcal{T}^r` and :math:`\mathcal{T}^s`.

For any member :math:`A_j` in the above sets, it may assume a *value* given in the real dataset :math:`\mathcal{T}^r` such that: 

:math:`V(A_j)` is the the set of all values that :math:`A_j` may take. The length of :math:`V(A_j)` is :math:`|V(A_j)|=N`.

We further define:

:math:`LO=\{AND, OR\}` is the set of logical operations.

:math:`CO=\{=, \ne,<,\leq, >,\geq \}` is the set of value comparison operations. 

:math:`AG=\{SUM, AVG, MIN, MAX\}` is the set of aggregate functions.

Random samples are drawn from the above sets to construct the three major queries defined below. The basic sampling functions can be defined as:

:math:`f_s: S_m \rightarrow S_s` where :math:`f_s` is a sampling function that maps any set :math:`S_m` into a single element set :math:`S_s`. For instance, the set :math:`AG` may be mapped by :math:`f_s` into :math:`\{AVG\}`

:math:`f_m: S_{m1} \rightarrow S_{m2}` where :math:`f_m` is a sampling function that maps any set :math:`S_{m1}` into a multiple element set :math:`S_{m2}`. For instance, the set :math:`\mathbb{A^n}` may be mapped by :math:`f_m` into :math:`\{A^n_1, A^n_{|\mathbb{A^n}|}\}`

Aggregate Queries
~~~~~~~~~~~~~~~~~
If :math:`\mathbb{A}^c = \phi`, an aggregate query takes the form:

.. math::
    :nowrap:

    \begin{flalign}
    \text{SELECT} \quad & f_m(\mathbb{A}^n) \text{, COUNT(*)} &&\\\nonumber
    \text{FROM} \quad & \mathcal{T}^r &&\\\nonumber
    \text{GROUP BY} \quad & f_m(\mathbb{A}^n)
    \end{flalign}

However, if :math:`\mathbb{A}^c \ne \phi`, an aggregate query takes the form:

.. math::
    :nowrap:

    \begin{flalign}
    \text{SELECT} \quad & f_m(\mathbb{A}^n), f_s(AG)(f_s(\mathbb{A}^c)) \text{, COUNT(*)} &&\\\nonumber
    \text{FROM} \quad & \mathcal{T}^r &&\\\nonumber
    \text{GROUP BY} \quad & f_m(\mathbb{A}^n)
    \end{flalign}

Similar queries are constructed for :math:`\mathcal{T^s}`.

Filter Queries
~~~~~~~~~~~~~~

If :math:`\mathbb{A}^c = \phi`, a filter query assumes the form:

.. math::
   :nowrap:

    \begin{flalign}
    \text{SELECT} \quad  & * &&\\\nonumber
    \text{FROM}   \quad  & \mathcal{T}^r &&\\\nonumber
    \text{WHERE}  \quad  & f_s(\mathbb{A}^n \cup \mathbb{A}^c \cup \mathbb{A}^d) \quad f_s(CO) \quad f_s(V(f_s(\mathbb{A}^n \cup \mathbb{A}^c \cup \mathbb{A}^d ))) &&\\\nonumber
                         & [f_s(LO) \quad (f_s(\mathbb{A}^n \cup \mathbb{A}^c \cup \mathbb{A}^d) \quad f_s(CO) \quad f_s(V(f_s(\mathbb{A}^n \cup \mathbb{A}^c \cup \mathbb{A}^d ))) \quad f_s(LO) \quad f_s(\mathbb{A}^n \cup \mathbb{A}^c \cup \mathbb{A}^d) \quad f_s(CO) \quad f_s(V(f_s(\mathbb{A}^n \cup \mathbb{A}^c \cup \mathbb{A}^d ))))] &&
    \end{flalign}




Filter-Aggregate Queries
~~~~~~~~~~~~~~~~~~~~~~~~
